// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `../../go_secure_utils.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class GoSecureUtilsBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  GoSecureUtilsBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  GoSecureUtilsBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// 生成RSA密钥对
  RsaKeyPair goRsaGenKeyPair(int bits) {
    return _goRsaGenKeyPair(bits);
  }

  late final _goRsaGenKeyPairPtr =
      _lookup<ffi.NativeFunction<RsaKeyPair Function(ffi.Int)>>(
        'goRsaGenKeyPair',
      );
  late final _goRsaGenKeyPair =
      _goRsaGenKeyPairPtr.asFunction<RsaKeyPair Function(int)>();

  /// 提取公钥
  ByteArray goRsaExtractPublicKey(
    ffi.Pointer<byte> privateKey,
    int privateKeyLen,
  ) {
    return _goRsaExtractPublicKey(privateKey, privateKeyLen);
  }

  late final _goRsaExtractPublicKeyPtr = _lookup<
    ffi.NativeFunction<ByteArray Function(ffi.Pointer<byte>, ffi.Int)>
  >('goRsaExtractPublicKey');
  late final _goRsaExtractPublicKey =
      _goRsaExtractPublicKeyPtr
          .asFunction<ByteArray Function(ffi.Pointer<byte>, int)>();

  /// 获取Base64编码的公钥
  StringResult goRsaGetPublicKeyBase64(
    ffi.Pointer<byte> publicKey,
    int publicKeyLen,
  ) {
    return _goRsaGetPublicKeyBase64(publicKey, publicKeyLen);
  }

  late final _goRsaGetPublicKeyBase64Ptr = _lookup<
    ffi.NativeFunction<StringResult Function(ffi.Pointer<byte>, ffi.Int)>
  >('goRsaGetPublicKeyBase64');
  late final _goRsaGetPublicKeyBase64 =
      _goRsaGetPublicKeyBase64Ptr
          .asFunction<StringResult Function(ffi.Pointer<byte>, int)>();

  /// 获取Base64编码的私钥
  StringResult goRsaGetPrivateKeyBase64(
    ffi.Pointer<byte> privateKey,
    int privateKeyLen,
  ) {
    return _goRsaGetPrivateKeyBase64(privateKey, privateKeyLen);
  }

  late final _goRsaGetPrivateKeyBase64Ptr = _lookup<
    ffi.NativeFunction<StringResult Function(ffi.Pointer<byte>, ffi.Int)>
  >('goRsaGetPrivateKeyBase64');
  late final _goRsaGetPrivateKeyBase64 =
      _goRsaGetPrivateKeyBase64Ptr
          .asFunction<StringResult Function(ffi.Pointer<byte>, int)>();

  /// 使用公钥加密数据
  ByteArray goRsaEncrypt(
    ffi.Pointer<byte> data,
    int dataLen,
    ffi.Pointer<byte> publicKey,
    int publicKeyLen,
  ) {
    return _goRsaEncrypt(data, dataLen, publicKey, publicKeyLen);
  }

  late final _goRsaEncryptPtr = _lookup<
    ffi.NativeFunction<
      ByteArray Function(ffi.Pointer<byte>, ffi.Int, ffi.Pointer<byte>, ffi.Int)
    >
  >('goRsaEncrypt');
  late final _goRsaEncrypt =
      _goRsaEncryptPtr
          .asFunction<
            ByteArray Function(ffi.Pointer<byte>, int, ffi.Pointer<byte>, int)
          >();

  /// 使用公钥加密数据并返回Base64编码的结果
  StringResult goRsaEncryptBase64(
    ffi.Pointer<byte> data,
    int dataLen,
    ffi.Pointer<byte> publicKey,
    int publicKeyLen,
  ) {
    return _goRsaEncryptBase64(data, dataLen, publicKey, publicKeyLen);
  }

  late final _goRsaEncryptBase64Ptr = _lookup<
    ffi.NativeFunction<
      StringResult Function(
        ffi.Pointer<byte>,
        ffi.Int,
        ffi.Pointer<byte>,
        ffi.Int,
      )
    >
  >('goRsaEncryptBase64');
  late final _goRsaEncryptBase64 =
      _goRsaEncryptBase64Ptr
          .asFunction<
            StringResult Function(
              ffi.Pointer<byte>,
              int,
              ffi.Pointer<byte>,
              int,
            )
          >();

  /// 使用私钥解密数据
  ByteArray goRsaDecrypt(
    ffi.Pointer<byte> encryptedData,
    int encryptedDataLen,
    ffi.Pointer<byte> privateKey,
    int privateKeyLen,
  ) {
    return _goRsaDecrypt(
      encryptedData,
      encryptedDataLen,
      privateKey,
      privateKeyLen,
    );
  }

  late final _goRsaDecryptPtr = _lookup<
    ffi.NativeFunction<
      ByteArray Function(ffi.Pointer<byte>, ffi.Int, ffi.Pointer<byte>, ffi.Int)
    >
  >('goRsaDecrypt');
  late final _goRsaDecrypt =
      _goRsaDecryptPtr
          .asFunction<
            ByteArray Function(ffi.Pointer<byte>, int, ffi.Pointer<byte>, int)
          >();

  /// 解密Base64编码的加密数据
  ByteArray goRsaDecryptFromBase64(
    ffi.Pointer<ffi.Char> encryptedBase64,
    ffi.Pointer<byte> privateKey,
    int privateKeyLen,
  ) {
    return _goRsaDecryptFromBase64(encryptedBase64, privateKey, privateKeyLen);
  }

  late final _goRsaDecryptFromBase64Ptr = _lookup<
    ffi.NativeFunction<
      ByteArray Function(ffi.Pointer<ffi.Char>, ffi.Pointer<byte>, ffi.Int)
    >
  >('goRsaDecryptFromBase64');
  late final _goRsaDecryptFromBase64 =
      _goRsaDecryptFromBase64Ptr
          .asFunction<
            ByteArray Function(ffi.Pointer<ffi.Char>, ffi.Pointer<byte>, int)
          >();

  /// 使用私钥对数据进行签名
  ByteArray goRsaSign(
    ffi.Pointer<byte> data,
    int dataLen,
    ffi.Pointer<byte> privateKey,
    int privateKeyLen,
  ) {
    return _goRsaSign(data, dataLen, privateKey, privateKeyLen);
  }

  late final _goRsaSignPtr = _lookup<
    ffi.NativeFunction<
      ByteArray Function(ffi.Pointer<byte>, ffi.Int, ffi.Pointer<byte>, ffi.Int)
    >
  >('goRsaSign');
  late final _goRsaSign =
      _goRsaSignPtr
          .asFunction<
            ByteArray Function(ffi.Pointer<byte>, int, ffi.Pointer<byte>, int)
          >();

  /// 使用私钥对字符串数据进行签名并返回Base64编码的结果
  StringResult goRsaSignBase64(
    ffi.Pointer<ffi.Char> data,
    ffi.Pointer<byte> privateKey,
    int privateKeyLen,
  ) {
    return _goRsaSignBase64(data, privateKey, privateKeyLen);
  }

  late final _goRsaSignBase64Ptr = _lookup<
    ffi.NativeFunction<
      StringResult Function(ffi.Pointer<ffi.Char>, ffi.Pointer<byte>, ffi.Int)
    >
  >('goRsaSignBase64');
  late final _goRsaSignBase64 =
      _goRsaSignBase64Ptr
          .asFunction<
            StringResult Function(ffi.Pointer<ffi.Char>, ffi.Pointer<byte>, int)
          >();

  /// 使用SHA1哈希算法和私钥对数据进行签名
  ByteArray goRsaSignSha1(
    ffi.Pointer<byte> data,
    int dataLen,
    ffi.Pointer<byte> privateKey,
    int privateKeyLen,
  ) {
    return _goRsaSignSha1(data, dataLen, privateKey, privateKeyLen);
  }

  late final _goRsaSignSha1Ptr = _lookup<
    ffi.NativeFunction<
      ByteArray Function(ffi.Pointer<byte>, ffi.Int, ffi.Pointer<byte>, ffi.Int)
    >
  >('goRsaSignSha1');
  late final _goRsaSignSha1 =
      _goRsaSignSha1Ptr
          .asFunction<
            ByteArray Function(ffi.Pointer<byte>, int, ffi.Pointer<byte>, int)
          >();

  /// 验证签名
  BoolResult goRsaVerify(
    ffi.Pointer<byte> data,
    int dataLen,
    ffi.Pointer<byte> publicKey,
    int publicKeyLen,
    ffi.Pointer<byte> signature,
    int signatureLen,
  ) {
    return _goRsaVerify(
      data,
      dataLen,
      publicKey,
      publicKeyLen,
      signature,
      signatureLen,
    );
  }

  late final _goRsaVerifyPtr = _lookup<
    ffi.NativeFunction<
      BoolResult Function(
        ffi.Pointer<byte>,
        ffi.Int,
        ffi.Pointer<byte>,
        ffi.Int,
        ffi.Pointer<byte>,
        ffi.Int,
      )
    >
  >('goRsaVerify');
  late final _goRsaVerify =
      _goRsaVerifyPtr
          .asFunction<
            BoolResult Function(
              ffi.Pointer<byte>,
              int,
              ffi.Pointer<byte>,
              int,
              ffi.Pointer<byte>,
              int,
            )
          >();

  /// 验证Base64编码的签名
  BoolResult goRsaVerifyFromBase64(
    ffi.Pointer<ffi.Char> data,
    ffi.Pointer<byte> publicKey,
    int publicKeyLen,
    ffi.Pointer<ffi.Char> signatureBase64,
  ) {
    return _goRsaVerifyFromBase64(
      data,
      publicKey,
      publicKeyLen,
      signatureBase64,
    );
  }

  late final _goRsaVerifyFromBase64Ptr = _lookup<
    ffi.NativeFunction<
      BoolResult Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<byte>,
        ffi.Int,
        ffi.Pointer<ffi.Char>,
      )
    >
  >('goRsaVerifyFromBase64');
  late final _goRsaVerifyFromBase64 =
      _goRsaVerifyFromBase64Ptr
          .asFunction<
            BoolResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<byte>,
              int,
              ffi.Pointer<ffi.Char>,
            )
          >();

  /// 使用SHA1哈希算法验证签名
  BoolResult goRsaVerifySha1(
    ffi.Pointer<byte> data,
    int dataLen,
    ffi.Pointer<byte> publicKey,
    int publicKeyLen,
    ffi.Pointer<byte> signature,
    int signatureLen,
  ) {
    return _goRsaVerifySha1(
      data,
      dataLen,
      publicKey,
      publicKeyLen,
      signature,
      signatureLen,
    );
  }

  late final _goRsaVerifySha1Ptr = _lookup<
    ffi.NativeFunction<
      BoolResult Function(
        ffi.Pointer<byte>,
        ffi.Int,
        ffi.Pointer<byte>,
        ffi.Int,
        ffi.Pointer<byte>,
        ffi.Int,
      )
    >
  >('goRsaVerifySha1');
  late final _goRsaVerifySha1 =
      _goRsaVerifySha1Ptr
          .asFunction<
            BoolResult Function(
              ffi.Pointer<byte>,
              int,
              ffi.Pointer<byte>,
              int,
              ffi.Pointer<byte>,
              int,
            )
          >();

  /// 释放ByteArray结构分配的内存
  void goFreeByteArray(ByteArray result) {
    return _goFreeByteArray(result);
  }

  late final _goFreeByteArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ByteArray)>>(
        'goFreeByteArray',
      );
  late final _goFreeByteArray =
      _goFreeByteArrayPtr.asFunction<void Function(ByteArray)>();

  /// 释放RsaKeyPair结构分配的内存
  void goFreeRsaKeyPair(RsaKeyPair result) {
    return _goFreeRsaKeyPair(result);
  }

  late final _goFreeRsaKeyPairPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(RsaKeyPair)>>(
        'goFreeRsaKeyPair',
      );
  late final _goFreeRsaKeyPair =
      _goFreeRsaKeyPairPtr.asFunction<void Function(RsaKeyPair)>();

  /// 释放StringResult结构分配的内存
  void goFreeStringResult(StringResult result) {
    return _goFreeStringResult(result);
  }

  late final _goFreeStringResultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(StringResult)>>(
        'goFreeStringResult',
      );
  late final _goFreeStringResult =
      _goFreeStringResultPtr.asFunction<void Function(StringResult)>();

  /// 释放BoolResult结构分配的内存
  void goFreeBoolResult(BoolResult result) {
    return _goFreeBoolResult(result);
  }

  late final _goFreeBoolResultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(BoolResult)>>(
        'goFreeBoolResult',
      );
  late final _goFreeBoolResult =
      _goFreeBoolResultPtr.asFunction<void Function(BoolResult)>();

  /// 保持对Go内存的引用，防止被垃圾回收
  void KeepAlive() {
    return _KeepAlive();
  }

  late final _KeepAlivePtr = _lookup<ffi.NativeFunction<ffi.Void Function()>>(
    'KeepAlive',
  );
  late final _KeepAlive = _KeepAlivePtr.asFunction<void Function()>();
}

/// 基本字节数组结构
final class ByteArray extends ffi.Struct {
  external ffi.Pointer<byte> data;

  @ffi.Int()
  external int length;

  /// NULL if no error
  external ffi.Pointer<ffi.Char> error;
}

typedef byte = ffi.Uint8;
typedef Dartbyte = int;

/// 密钥对结构
final class RsaKeyPair extends ffi.Struct {
  external ByteArray publicKey;

  external ByteArray privateKey;

  /// NULL if no error
  external ffi.Pointer<ffi.Char> error;
}

/// 字符串结果结构
final class StringResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> data;

  /// NULL if no error
  external ffi.Pointer<ffi.Char> error;
}

/// 布尔结果结构
final class BoolResult extends ffi.Struct {
  /// 1 for true, 0 for false
  @ffi.Int()
  external int success;

  /// NULL if no error
  external ffi.Pointer<ffi.Char> error;
}
